<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>力扣笔记 | ChengHuiWan-cy的博客</title><meta name="author" content="ChengHuiWan-cy"><meta name="copyright" content="ChengHuiWan-cy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这篇文章主要是记录刷过的题以及里面一些需要注意的关键点(https:&#x2F;&#x2F;www.programmercarl.com&#x2F;) 1.做题记录   序号 题目 日期 类型 链接    1 704.二分查找 2024年7月5日 数组 https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;binary-search&#x2F;description&#x2F;   2 27.移除元素 2024年7月5日 数组 https:&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="力扣笔记">
<meta property="og:url" content="https://chenghuiwan-cy.github.io/2024/07/05/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="ChengHuiWan-cy的博客">
<meta property="og:description" content="这篇文章主要是记录刷过的题以及里面一些需要注意的关键点(https:&#x2F;&#x2F;www.programmercarl.com&#x2F;) 1.做题记录   序号 题目 日期 类型 链接    1 704.二分查找 2024年7月5日 数组 https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;binary-search&#x2F;description&#x2F;   2 27.移除元素 2024年7月5日 数组 https:&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chenghuiwan-cy.github.io/img/3.jpg">
<meta property="article:published_time" content="2024-07-05T05:55:27.000Z">
<meta property="article:modified_time" content="2024-08-16T16:02:06.456Z">
<meta property="article:author" content="ChengHuiWan-cy">
<meta property="article:tag" content="leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chenghuiwan-cy.github.io/img/3.jpg"><link rel="shortcut icon" href="https://avatars.githubusercontent.com/u/77524161?v=4"><link rel="canonical" href="https://chenghuiwan-cy.github.io/2024/07/05/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '力扣笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-17 00:02:06'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/u/77524161?v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/3.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="ChengHuiWan-cy的博客"><span class="site-name">ChengHuiWan-cy的博客</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">力扣笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-05T05:55:27.000Z" title="发表于 2024-07-05 13:55:27">2024-07-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-16T16:02:06.456Z" title="更新于 2024-08-17 00:02:06">2024-08-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/">自我提升</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="力扣笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>这篇文章主要是记录刷过的题以及里面一些需要注意的关键点(<a target="_blank" rel="noopener" href="https://www.programmercarl.com/">https://www.programmercarl.com/</a>)</p>
<h1 id="1-做题记录"><a href="#1-做题记录" class="headerlink" title="1.做题记录"></a>1.做题记录</h1><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">题目</th>
<th align="center">日期</th>
<th align="center">类型</th>
<th align="center">链接</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">704.二分查找</td>
<td align="center">2024年7月5日</td>
<td align="center">数组</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/description/">https://leetcode.cn/problems/binary-search/description/</a></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">27.移除元素</td>
<td align="center">2024年7月5日</td>
<td align="center">数组</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/description/">https://leetcode.cn/problems/remove-element/description/</a></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">977.有序数组的平方</td>
<td align="center">2024年7月5日</td>
<td align="center">数组</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">https://leetcode.cn/problems/squares-of-a-sorted-array/description/</a></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">209.长度最小的子数组</td>
<td align="center">2024年7月5日</td>
<td align="center">数组</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">https://leetcode.cn/problems/minimum-size-subarray-sum/description/</a></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">59.螺旋矩阵II</td>
<td align="center">2024年7月5日</td>
<td align="center">数组</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/description/">https://leetcode.cn/problems/spiral-matrix-ii/description/</a></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">203.移除链表元素</td>
<td align="center">2024年7月6日</td>
<td align="center">链表</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/description/">https://leetcode.cn/problems/remove-linked-list-elements/description/</a></td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">206.反转链表</td>
<td align="center">2024年7月6日</td>
<td align="center">链表</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/description/">https://leetcode.cn/problems/reverse-linked-list/description/</a></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">24. 两两交换链表中的节点</td>
<td align="center">2024年7月6日</td>
<td align="center">链表</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">https://leetcode.cn/problems/swap-nodes-in-pairs/description/</a></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">19.删除链表的倒数第N个节点</td>
<td align="center">2024年7月6日</td>
<td align="center">链表</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/</a></td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">160. 相交链表</td>
<td align="center">2024年7月6日</td>
<td align="center">链表</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">https://leetcode.cn/problems/intersection-of-two-linked-lists/</a></td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">142.环形链表II</td>
<td align="center">2024年7月6日</td>
<td align="center">链表</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">https://leetcode.cn/problems/linked-list-cycle-ii/description/</a></td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">242.有效的字母异位词</td>
<td align="center">2024年7月7日</td>
<td align="center">哈希表</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/description/">https://leetcode.cn/problems/valid-anagram/description/</a></td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">349. 两个数组的交集</td>
<td align="center">2024年7月7日</td>
<td align="center">哈希表</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">https://leetcode.cn/problems/intersection-of-two-arrays/description/</a></td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">202.快乐数</td>
<td align="center">2024年7月7日</td>
<td align="center">哈希表</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/description/">https://leetcode.cn/problems/happy-number/description/</a></td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">1.两数之和</td>
<td align="center">2024年7月7日</td>
<td align="center">哈希表</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/description/">https://leetcode.cn/problems/two-sum/description/</a></td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">383. 赎金信</td>
<td align="center">2024年7月7日</td>
<td align="center">哈希表</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/description/">https://leetcode.cn/problems/ransom-note/description/</a></td>
</tr>
<tr>
<td align="center">17</td>
<td align="center">15.三数之和</td>
<td align="center">2024年7月7日</td>
<td align="center">哈希表</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/description/">https://leetcode.cn/problems/3sum/description/</a></td>
</tr>
<tr>
<td align="center">18</td>
<td align="center">18.四数之和</td>
<td align="center">2024年7月8日</td>
<td align="center">哈希表</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/description/">https://leetcode.cn/problems/4sum/description/</a></td>
</tr>
<tr>
<td align="center">19</td>
<td align="center">454.四数相加II</td>
<td align="center">2024年7月8日</td>
<td align="center">哈希表</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/description/">https://leetcode.cn/problems/4sum-ii/description/</a></td>
</tr>
<tr>
<td align="center">20</td>
<td align="center">344.反转字符串</td>
<td align="center">2024年7月8日</td>
<td align="center">字符串</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/description/">https://leetcode.cn/problems/reverse-string/description/</a></td>
</tr>
<tr>
<td align="center">21</td>
<td align="center">541. 反转字符串II</td>
<td align="center">2024年7月8日</td>
<td align="center">字符串</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/description/">https://leetcode.cn/problems/reverse-string-ii/description/</a></td>
</tr>
<tr>
<td align="center">22</td>
<td align="center">509. 斐波那契数</td>
<td align="center">2024年7月8日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/description/">https://leetcode.cn/problems/fibonacci-number/description/</a></td>
</tr>
<tr>
<td align="center">23</td>
<td align="center">70. 爬楼梯</td>
<td align="center">2024年7月8日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/description/">https://leetcode.cn/problems/climbing-stairs/description/</a></td>
</tr>
<tr>
<td align="center">24</td>
<td align="center">746. 使用最小花费爬楼梯</td>
<td align="center">2024年7月8日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/description/">https://leetcode.cn/problems/min-cost-climbing-stairs/description/</a></td>
</tr>
<tr>
<td align="center">25</td>
<td align="center">62.不同路径</td>
<td align="center">2024年7月8日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/description/">https://leetcode.cn/problems/unique-paths/description/</a></td>
</tr>
<tr>
<td align="center">26</td>
<td align="center">63. 不同路径 II</td>
<td align="center">2024年7月8日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/description/">https://leetcode.cn/problems/unique-paths-ii/description/</a></td>
</tr>
<tr>
<td align="center">27</td>
<td align="center">343. 整数拆分</td>
<td align="center">2024年7月8日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/description/">https://leetcode.cn/problems/integer-break/description/</a></td>
</tr>
<tr>
<td align="center">28</td>
<td align="center">96.不同的二叉搜索树</td>
<td align="center">2024年7月8日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/description/">https://leetcode.cn/problems/unique-binary-search-trees/description/</a></td>
</tr>
<tr>
<td align="center">29</td>
<td align="center">416. 分割等和子集</td>
<td align="center">2024年7月8日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">https://leetcode.cn/problems/partition-equal-subset-sum/description/</a></td>
</tr>
<tr>
<td align="center">30</td>
<td align="center">279.完全平方数</td>
<td align="center">2024年7月8日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/description/">https://leetcode.cn/problems/perfect-squares/description/</a></td>
</tr>
<tr>
<td align="center">31</td>
<td align="center">121. 买卖股票的最佳时机</td>
<td align="center">2024年7月8日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/</a></td>
</tr>
<tr>
<td align="center">32</td>
<td align="center">122.买卖股票的最佳时机II</td>
<td align="center">2024年7月8日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/</a></td>
</tr>
<tr>
<td align="center">33</td>
<td align="center">123.买卖股票的最佳时机III</td>
<td align="center">2024年7月8日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/</a></td>
</tr>
<tr>
<td align="center">34</td>
<td align="center">188.买卖股票的最佳时机IV</td>
<td align="center">2024年7月8日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/</a></td>
</tr>
<tr>
<td align="center">35</td>
<td align="center">714.买卖股票的最佳时机含手续费</td>
<td align="center">2024年7月8日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/</a></td>
</tr>
<tr>
<td align="center">36</td>
<td align="center">647. 回文子串</td>
<td align="center">2024年7月9日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/description/">https://leetcode.cn/problems/palindromic-substrings/description/</a></td>
</tr>
<tr>
<td align="center">37</td>
<td align="center">198.打家劫舍</td>
<td align="center">2024年7月10日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/description/">https://leetcode.cn/problems/house-robber/description/</a></td>
</tr>
<tr>
<td align="center">38</td>
<td align="center">213.打家劫舍II</td>
<td align="center">2024年7月10日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-ii/description/">https://leetcode.cn/problems/house-robber-ii/description/</a></td>
</tr>
<tr>
<td align="center">39</td>
<td align="center">337.打家劫舍 III</td>
<td align="center">2024年7月10日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/description/">https://leetcode.cn/problems/house-robber-iii/description/</a></td>
</tr>
<tr>
<td align="center">40</td>
<td align="center">20. 有效的括号</td>
<td align="center">2024年7月10日</td>
<td align="center">栈与队列</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/description/">https://leetcode.cn/problems/valid-parentheses/description/</a></td>
</tr>
<tr>
<td align="center">41</td>
<td align="center">1047. 删除字符串中的所有相邻重复项</td>
<td align="center">2024年7月10日</td>
<td align="center">栈与队列</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/</a></td>
</tr>
<tr>
<td align="center">42</td>
<td align="center">150. 逆波兰表达式求值</td>
<td align="center">2024年7月10日</td>
<td align="center">栈与队列</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/</a></td>
</tr>
<tr>
<td align="center">43</td>
<td align="center">347.前 K 个高频元素</td>
<td align="center">2024年7月10日</td>
<td align="center">栈与队列</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/description/">https://leetcode.cn/problems/top-k-frequent-elements/description/</a></td>
</tr>
<tr>
<td align="center">44</td>
<td align="center">455.分发饼干</td>
<td align="center">2024年7月10日</td>
<td align="center">贪心算法</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies/description/">https://leetcode.cn/problems/assign-cookies/description/</a></td>
</tr>
<tr>
<td align="center">45</td>
<td align="center">376. 摆动序列</td>
<td align="center">2024年7月10日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/wiggle-subsequence/description/">https://leetcode.cn/problems/wiggle-subsequence/description/</a></td>
</tr>
<tr>
<td align="center">46</td>
<td align="center">53. 最大子序和</td>
<td align="center">2024年7月10日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/description/">https://leetcode.cn/problems/maximum-subarray/description/</a></td>
</tr>
<tr>
<td align="center">47</td>
<td align="center">300.最长递增子序列</td>
<td align="center">2024年7月10日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">https://leetcode.cn/problems/longest-increasing-subsequence/description/</a></td>
</tr>
<tr>
<td align="center">48</td>
<td align="center">674. 最长连续递增序列</td>
<td align="center">2024年7月10日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/">https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/</a></td>
</tr>
<tr>
<td align="center">49</td>
<td align="center">1365.有多少小于当前数字的数字</td>
<td align="center">2024年7月10日</td>
<td align="center">数组</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/description/">https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/description/</a></td>
</tr>
<tr>
<td align="center">50</td>
<td align="center">941.有效的山脉数组</td>
<td align="center">2024年7月10日</td>
<td align="center">数组</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-mountain-array/description/">https://leetcode.cn/problems/valid-mountain-array/description/</a></td>
</tr>
<tr>
<td align="center">51</td>
<td align="center">1207.独一无二的出现次数</td>
<td align="center">2024年7月11日</td>
<td align="center">数组</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-number-of-occurrences/description/">https://leetcode.cn/problems/unique-number-of-occurrences/description/</a></td>
</tr>
<tr>
<td align="center">52</td>
<td align="center">283. 移动零</td>
<td align="center">2024年7月11日</td>
<td align="center">数组</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/description/">https://leetcode.cn/problems/move-zeroes/description/</a></td>
</tr>
<tr>
<td align="center">53</td>
<td align="center">189. 旋转数组</td>
<td align="center">2024年7月11日</td>
<td align="center">数组</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-array/description/">https://leetcode.cn/problems/rotate-array/description/</a></td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">724.寻找数组的中心下标</td>
<td align="center">2024年7月11日</td>
<td align="center">数组</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-pivot-index/description/">https://leetcode.cn/problems/find-pivot-index/description/</a></td>
</tr>
<tr>
<td align="center">55</td>
<td align="center">922. 按奇偶排序数组II</td>
<td align="center">2024年7月11日</td>
<td align="center">数组</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-array-by-parity-ii/description/">https://leetcode.cn/problems/sort-array-by-parity-ii/description/</a></td>
</tr>
<tr>
<td align="center">56</td>
<td align="center">1356. 根据数字二进制下 1 的数目排序</td>
<td align="center">2024年7月12日</td>
<td align="center">01运算</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits/description/">https://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits/description/</a></td>
</tr>
<tr>
<td align="center">57</td>
<td align="center">77.组合</td>
<td align="center">2024年7月12日</td>
<td align="center">回溯算法</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/description/">https://leetcode.cn/problems/combinations/description/</a></td>
</tr>
<tr>
<td align="center">58</td>
<td align="center">216.组合总和III</td>
<td align="center">2024年7月13日</td>
<td align="center">回溯算法</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/description/">https://leetcode.cn/problems/combination-sum-iii/description/</a></td>
</tr>
<tr>
<td align="center">59</td>
<td align="center">17.电话号码的字母组合</td>
<td align="center">2024年7月15日</td>
<td align="center">回溯算法</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/</a></td>
</tr>
<tr>
<td align="center">60</td>
<td align="center">131.分割回文串</td>
<td align="center">2024年7月15日</td>
<td align="center">回溯算法</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/description/">https://leetcode.cn/problems/palindrome-partitioning/description/</a></td>
</tr>
<tr>
<td align="center">61</td>
<td align="center">860.柠檬水找零</td>
<td align="center">2024年7月15日</td>
<td align="center">贪心算法</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lemonade-change/description/">https://leetcode.cn/problems/lemonade-change/description/</a></td>
</tr>
<tr>
<td align="center">62</td>
<td align="center">135. 分发糖果</td>
<td align="center">2024年7月15日</td>
<td align="center">贪心算法</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/description/">https://leetcode.cn/problems/candy/description/</a></td>
</tr>
<tr>
<td align="center">63</td>
<td align="center">55. 跳跃游戏</td>
<td align="center">2024年7月16日</td>
<td align="center">贪心算法</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/description/">https://leetcode.cn/problems/jump-game/description/</a></td>
</tr>
<tr>
<td align="center">64</td>
<td align="center">1005.K次取反后最大化的数组和</td>
<td align="center">2024年7月16日</td>
<td align="center">贪心算法</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/">https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/</a></td>
</tr>
<tr>
<td align="center">65</td>
<td align="center">452. 用最少数量的箭引爆气球</td>
<td align="center">2024年7月17日</td>
<td align="center">贪心算法</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/">https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/</a></td>
</tr>
<tr>
<td align="center">66</td>
<td align="center">435. 无重叠区间</td>
<td align="center">2024年7月17日</td>
<td align="center">贪心算法</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/description/">https://leetcode.cn/problems/non-overlapping-intervals/description/</a></td>
</tr>
<tr>
<td align="center">67</td>
<td align="center">763.划分字母区间</td>
<td align="center">2024年7月17日</td>
<td align="center">贪心算法</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/description/">https://leetcode.cn/problems/partition-labels/description/</a></td>
</tr>
<tr>
<td align="center">68</td>
<td align="center">1143.最长公共子序列</td>
<td align="center">2024年7月19日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/description/">https://leetcode.cn/problems/longest-common-subsequence/description/</a></td>
</tr>
<tr>
<td align="center">69</td>
<td align="center">1035.不相交的线</td>
<td align="center">2024年7月19日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/uncrossed-lines/description/">https://leetcode.cn/problems/uncrossed-lines/description/</a></td>
</tr>
<tr>
<td align="center">70</td>
<td align="center">718. 最长重复子数组</td>
<td align="center">2024年7月19日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/</a></td>
</tr>
<tr>
<td align="center">71</td>
<td align="center">1049.最后一块石头的重量II</td>
<td align="center">2024年8月2日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/description/">https://leetcode.cn/problems/last-stone-weight-ii/description/</a></td>
</tr>
<tr>
<td align="center">72</td>
<td align="center">494.目标和</td>
<td align="center">2024年8月3日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/description/">https://leetcode.cn/problems/target-sum/description/</a></td>
</tr>
<tr>
<td align="center">73</td>
<td align="center">474.一和零</td>
<td align="center">2024年8月3日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/description/">https://leetcode.cn/problems/ones-and-zeroes/description/</a></td>
</tr>
<tr>
<td align="center">74</td>
<td align="center">518.零钱兑换II</td>
<td align="center">2024年8月3日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/description/">https://leetcode.cn/problems/coin-change-ii/description/</a></td>
</tr>
<tr>
<td align="center">75</td>
<td align="center">377. 组合总和 Ⅳ</td>
<td align="center">2024年8月4日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/description/">https://leetcode.cn/problems/combination-sum-iv/description/</a></td>
</tr>
<tr>
<td align="center">76</td>
<td align="center">322. 零钱兑换</td>
<td align="center">2024年8月4日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/description/">https://leetcode.cn/problems/coin-change/description/</a></td>
</tr>
<tr>
<td align="center">77</td>
<td align="center">309.最佳买卖股票时机含冷冻期</td>
<td align="center">2024年8月4日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/</a></td>
</tr>
<tr>
<td align="center">78</td>
<td align="center">392.判断子序列</td>
<td align="center">2024年8月4日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/description/">https://leetcode.cn/problems/is-subsequence/description/</a></td>
</tr>
<tr>
<td align="center">79</td>
<td align="center">115.不同的子序列</td>
<td align="center">2024年8月5日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences/description/">https://leetcode.cn/problems/distinct-subsequences/description/</a></td>
</tr>
<tr>
<td align="center">80</td>
<td align="center">583. 两个字符串的删除操作</td>
<td align="center">2024年8月6日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/description/">https://leetcode.cn/problems/delete-operation-for-two-strings/description/</a></td>
</tr>
<tr>
<td align="center">81</td>
<td align="center">72. 编辑距离</td>
<td align="center">2024年8月6日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/description/">https://leetcode.cn/problems/edit-distance/description/</a></td>
</tr>
<tr>
<td align="center">82</td>
<td align="center">516.最长回文子序列</td>
<td align="center">2024年8月7日</td>
<td align="center">动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/description/">https://leetcode.cn/problems/longest-palindromic-subsequence/description/</a></td>
</tr>
<tr>
<td align="center">83</td>
<td align="center">739. 每日温度</td>
<td align="center">2024年8月7日</td>
<td align="center">单调栈</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/description/">https://leetcode.cn/problems/daily-temperatures/description/</a></td>
</tr>
<tr>
<td align="center">84</td>
<td align="center">496.下一个更大元素 I</td>
<td align="center">2024年8月16日</td>
<td align="center">单调栈</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/description/">https://leetcode.cn/problems/next-greater-element-i/description/</a></td>
</tr>
<tr>
<td align="center">85</td>
<td align="center">503.下一个更大元素II</td>
<td align="center">2024年8月16日</td>
<td align="center">单调栈</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-ii/description/">https://leetcode.cn/problems/next-greater-element-ii/description/</a></td>
</tr>
<tr>
<td align="center">86</td>
<td align="center">42. 接雨水</td>
<td align="center">2024年8月16日</td>
<td align="center">双指针+动态规划</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/description/">https://leetcode.cn/problems/trapping-rain-water/description/</a></td>
</tr>
<tr>
<td align="center">87</td>
<td align="center">84.柱状图中最大的矩形</td>
<td align="center">2024年8月17日</td>
<td align="center">双指针+单调栈</td>
<td align="center"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">https://leetcode.cn/problems/largest-rectangle-in-histogram/description/</a></td>
</tr>
</tbody></table>
<h1 id="2-一些java用法"><a href="#2-一些java用法" class="headerlink" title="2.一些java用法"></a>2.一些java用法</h1><p>put+remove(HashMap),add+remove</p>
<h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><p>平方根函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">f</span> <span class="operator">=</span> Math.sqrt(n);</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);</span><br></pre></td></tr></table></figure>

<p>打印数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.toString(array));</span><br></pre></td></tr></table></figure>

<p>数组初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.fill(nums, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>数组获得复制数组（并不指向同一地址）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] num = Arrays.copyOf(nums, len);</span><br></pre></td></tr></table></figure>

<p>int[]数组自定义排序规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Arrays.stream(arr).boxed().sorted(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer num1, Integer num2)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> count1(num1);</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> count1(num2);</span><br><span class="line">                <span class="keyword">return</span> (a == b) ? Integer.compare(num1, num2) : Integer.compare(a, b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).mapToInt(Integer::intValue).toArray();</span><br></pre></td></tr></table></figure>

<p>这段代码使用了Java 8及以上版本的Stream API来处理一个整数数组（假设这个数组名为<code>arr</code>），尽管初始代码段中并没有直接显示<code>arr</code>的声明和类型，但从上下文可以推断出<code>arr</code>是一个<code>int[]</code>类型的数组。接下来，我将逐步解释这段代码的作用：</p>
<ol>
<li><code>Arrays.stream(arr).boxed()</code>:<ul>
<li><code>Arrays.stream(arr)</code>将<code>int[]</code>数组<code>arr</code>转换为一个<code>IntStream</code>，这是Java Stream API的一部分，专门用于处理基本数据类型<code>int</code>的序列。</li>
<li><code>.boxed()</code>方法将<code>IntStream</code>转换为<code>Stream&lt;Integer&gt;</code>。这是因为<code>IntStream</code>处理的是基本类型<code>int</code>，而<code>Stream&lt;Integer&gt;</code>处理的是对象类型<code>Integer</code>。这一步骤是必要的，因为接下来的排序和比较操作需要<code>Integer</code>对象，因为它们依赖于<code>Comparator</code>接口，该接口是为对象类型设计的。</li>
</ul>
</li>
<li><code>.sorted(new Comparator&lt;Integer&gt;()&#123;...&#125;)</code>:<ul>
<li><code>.sorted(...)</code>方法接收一个<code>Comparator&lt;Integer&gt;</code>作为参数，用于定义排序逻辑。</li>
<li>在这个<code>Comparator</code>中，<code>compare</code>方法被重写以定义排序规则。它首先调用一个假定的<code>cntInt(Integer)</code>方法（该方法在代码段中没有给出，但我们可以假设它接受一个<code>Integer</code>并返回一个整数值，这个值可能表示该整数在另一个集合中出现的次数或某种与整数相关联的计数）。</li>
<li>然后，它比较两个整数的<code>cntInt</code>返回值（<code>cnt1</code>和<code>cnt2</code>）。如果这两个计数相同，则使用<code>Integer.compare(o1, o2)</code>来按整数的自然顺序（即数值大小）进行排序。如果计数不同，则根据计数的大小进行排序。</li>
</ul>
</li>
<li><code>.mapToInt(Integer::intValue)</code>:<ul>
<li><code>.mapToInt(Integer::intValue)</code>将<code>Stream&lt;Integer&gt;</code>转换回<code>IntStream</code>。这是因为排序和比较完成后，可能希望将结果转换回基本类型的数组以节省内存或出于其他性能考虑。</li>
<li><code>Integer::intValue</code>是一个方法引用，它引用了<code>Integer</code>对象的<code>intValue()</code>方法，该方法返回<code>Integer</code>对象封装的<code>int</code>值。</li>
</ul>
</li>
<li><code>.toArray()</code>:<ul>
<li>最后，<code>.toArray()</code>方法将<code>IntStream</code>转换回<code>int[]</code>数组。这是整个链式调用的结果，现在是一个按照自定义排序逻辑（基于<code>cntInt</code>方法的返回值和整数的自然顺序）排序的整数数组。</li>
</ul>
</li>
</ol>
<h2 id="栈Stack"><a href="#栈Stack" class="headerlink" title="栈Stack"></a>栈Stack</h2><p>栈的初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;TreeNode&gt; myStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>栈的基本操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myStack.push(cur);</span><br><span class="line">cur = myStack.pop();</span><br><span class="line">cur = myStack.peek();<span class="comment">//只是查看栈顶元素，不会改变栈的内容</span></span><br></pre></td></tr></table></figure>

<h2 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h2><h3 id="使用LinkedList实现Queue"><a href="#使用LinkedList实现Queue" class="headerlink" title="使用LinkedList实现Queue"></a>使用LinkedList实现Queue</h3><p>队列的初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;TreeNode&gt; myQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>队列的基本操作（因为上述Queue的初始化是通过LinkedList实现的，所以此队列的操作函数与LinkedList一致）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myQueue.add(root);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> myQueue.removeLast();<span class="comment">//删除队尾</span></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> myQueue.poll();<span class="comment">//删除队头</span></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> myQueue.peek();</span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> myQueue.size();<span class="comment">//获得大小</span></span><br><span class="line"><span class="keyword">while</span>(!myQueue.isEmpty())<span class="comment">//判断是否为空</span></span><br></pre></td></tr></table></figure>

<h2 id="堆PriorityQueue"><a href="#堆PriorityQueue" class="headerlink" title="堆PriorityQueue"></a>堆PriorityQueue</h2><p>PriorityQueue 默认是小根堆，大顶堆定义：（基本操作和队列一致）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; bigHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br></pre></td></tr></table></figure>



<h2 id="链表List"><a href="#链表List" class="headerlink" title="链表List"></a>链表List</h2><p>链表的实现分为ArrayList和LinkedList</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList链表的初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; me = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//嵌套的list，右侧也只需要写一个括号就可以</span></span><br></pre></td></tr></table></figure>

<p>LinkedList链表的基本操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result.add(me);</span><br><span class="line">Collections.reverse(result);<span class="comment">//翻转list</span></span><br><span class="line"><span class="keyword">for</span> (Node child : cur.children)<span class="comment">//遍历list</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size()<span class="comment">//获得list的大小</span></span><br></pre></td></tr></table></figure>

<p>关于链表删除：list.remove()的问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; randomNumbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 删除第一次出现13的元素</span></span><br><span class="line">randomNumbers.remove(Integer.valueOf(<span class="number">13</span>));</span><br><span class="line"><span class="comment">// 删除13位置的元素，而不是元素13，因为元素13的类型是Integer</span></span><br><span class="line">randomNumbers.remove(<span class="number">13</span>);</span><br></pre></td></tr></table></figure>



<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>char[]转String:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray); </span><br></pre></td></tr></table></figure>

<p>字符串长度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br></pre></td></tr></table></figure>

<p>关于数组Array的长度获取是arr.length，但是字符串String的长度获取是str.length()的原因：</p>
<ul>
<li><p>数组在Java中是一种基础数据类型，但也被视为对象（因为它们有引用类型的特性）。数组一旦被创建，其长度就是固定的，并且<strong>这个长度信息是作为数组对象的一部分直接存储的</strong>。因此，当你访问<code>array.length</code>时，实际上是在直接访问这个数组对象的内置属性（或者说元数据），而不是在调用一个方法。这就是为什么不需要括号的原因——因为这不是一个函数调用，而是一个直接访问操作。</p>
</li>
<li><p>字符串（<code>String</code>）在Java中是一个类（<code>java.lang.String</code>），而不是基础数据类型。这意味着<strong>字符串是一个对象，拥有属性和方法。<code>String</code>类的<code>length()</code>方法是一个实例方法，用于返回字符串的长度。</strong>由于这是一个方法调用，所以需要使用括号来包围参数（尽管<code>length()</code>方法不接受任何参数，但括号是必须的，以区分于属性访问）。</p>
</li>
</ul>
<p>获取字符串某个位置的元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>遍历字符串：使用for+str.charAt()</p>
<p>String转char[]:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] array = str.toCharArray();</span><br></pre></td></tr></table></figure>

<p>注：String对象一旦创建，实体是不可以变化的，即内容不能再修改</p>
<p>判断相等：</p>
<p>&#x3D;&#x3D;判断的是否为同一对象，str.equals(“abc”)判断的是内容</p>
<p>子串切割：注意切割之后的子串是[i,j)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = str.substring(i,j);</span><br></pre></td></tr></table></figure>



<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>字符串String倒置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str).reverse().toString();</span><br></pre></td></tr></table></figure>



<h2 id="集合Set-Collections"><a href="#集合Set-Collections" class="headerlink" title="集合Set(Collections)"></a>集合Set(Collections)</h2><p>集合的初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>集合的遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">通过foreach</span><br><span class="line"><span class="title function_">for</span><span class="params">(String s:set)</span>&#123;</span><br><span class="line">    System.out.println(s); </span><br><span class="line">&#125;</span><br><span class="line">遍历，通过迭代器</span><br><span class="line">Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>集合添加元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.add(“one”);</span><br></pre></td></tr></table></figure>

<p>集合删除元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.remove(“one”);</span><br></pre></td></tr></table></figure>

<p>集合是否包含元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(set.contains(“one”))&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>集合转数组：</p>
<p>需要注意，new String[0]新建了一个String数组，但是它的长度是0。其作用是，<strong>1.<strong>告诉<code>toArray</code>方法你期望的数组类型是什么，这对于泛型集合尤为重要，因为泛型信息在运行时会被擦除，所以<code>toArray</code>方法需要某种方式来知道它应该创建什么类型的数组。</strong>2.触发新数组分配</strong>：由于数组的长度为0，显然不足以存储集合中的任何元素（除非集合本身就是空的）。因此，<code>toArray</code>方法会意识到需要分配一个新的数组来存储所有元素。</p>
<p>当然，如果你知道集合的大小（或至少有一个合理的估计），传入一个足够大的数组可能会更有效率。如果传入的数组足够大以容纳集合中的所有元素，<code>toArray</code>方法就会直接在这个数组中填充元素，而不是分配一个新的数组。然而，这要求你能够提前知道或估计集合的大小，这在很多情况下是不可行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] strings = hashSet.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]); </span><br></pre></td></tr></table></figure>

<p>另外：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); </span><br><span class="line">Integer[] integers = result.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>这种方法只能直接转成Integer[ ]，而不能直接转成int[ ]，可以使用下面的思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> result.stream()  </span><br><span class="line">    .mapToInt(Integer::intValue)  <span class="comment">//将Stream&lt;Integer&gt;转换为IntStream  </span></span><br><span class="line">    .toArray();  <span class="comment">//使用toArray()无参版本会返回int[]数组</span></span><br></pre></td></tr></table></figure>

<h2 id="映射Map-Collections"><a href="#映射Map-Collections" class="headerlink" title="映射Map(Collections)"></a>映射Map(Collections)</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>增加元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;one&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>查找元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(map.get(<span class="string">&quot;one&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>移除元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.remove(<span class="string">&quot;three&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>是否包含元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.containsKey(<span class="string">&quot;one&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果找不到元素，返回默认值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.getOrDefault(<span class="number">1</span>, <span class="string">&quot;Not Found&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Map的遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : me.keySet())</span><br></pre></td></tr></table></figure>



<h1 id="3-做题笔记"><a href="#3-做题笔记" class="headerlink" title="3.做题笔记"></a>3.做题笔记</h1><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h3><p>二分的特征：升序+无重复</p>
<p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p>
<p><strong>定义target在[left, right]区间</strong>：</p>
<ul>
<li>while (left &lt;&#x3D; right) 要使用 &lt;&#x3D; ，因为left &#x3D;&#x3D; right是有意义的，所以使用 &lt;&#x3D;</li>
<li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li>
</ul>
<p>防止溢出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + ((right - left) / <span class="number">2</span>); 防止溢出 等同于(left + right)/<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h3><p>区间的定义是[left,right]:</p>
<ul>
<li>while(left&lt;&#x3D;right)</li>
<li>left++;right–;</li>
</ul>
<p>因为while的过程当中可能会超出限制，所以要while (left &lt;&#x3D; nums.length - 1 &amp;&amp; nums[left] !&#x3D; val)，而且要if (left &lt;&#x3D; right)再交换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">         左右快慢指针，区间是[l,r]</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left&lt;=nums.length-<span class="number">1</span>&amp;&amp;nums[left] != val) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (right&gt;=<span class="number">0</span>&amp;&amp;nums[right] == val) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right ) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[left];</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                nums[right] = temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a>977. 有序数组的平方</h3><p>双指针，绝对值最大的数字一定是在两边，结果数组的最后一位由双指针确定，结果数组从后往前依次确定</p>
<h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">         双指针构成滑动窗口，区间是[l,r]</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> nums.length + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left; right &lt; nums.length; right++) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;注意这里</span><br><span class="line">                result = Math.min(result, right - left + <span class="number">1</span>);</span><br><span class="line">                sum = sum - nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == nums.length + <span class="number">1</span> ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h3><p>需要注意：</p>
<ul>
<li>确定好每一次的填充都是左闭右开的填充</li>
<li>奇数的矩阵要比偶数的矩阵再多一个填充中间位置的元素的步骤</li>
</ul>
<h3 id="1365-有多少小于当前数字的数字"><a href="#1365-有多少小于当前数字的数字" class="headerlink" title="1365.有多少小于当前数字的数字"></a>1365.有多少小于当前数字的数字</h3><p>排序，map记录( nums[i] , 几个比它小的数 )</p>
<p>最后按照原来数组的顺序依次在map当中寻找结果</p>
<h3 id="941-有效的山脉数组"><a href="#941-有效的山脉数组" class="headerlink" title="941.有效的山脉数组"></a>941.有效的山脉数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validMountainArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.根据isTop来判断是否已经达到顶峰</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="number">1</span>] &lt; arr[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// true之后所有的元素都要严格下降</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isTop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[i - <span class="number">1</span>] &amp;&amp; isTop == <span class="literal">false</span>) &#123;</span><br><span class="line">                isTop = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isTop &amp;&amp; arr[i] &gt;= arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isTop;</span><br><span class="line">        <span class="comment">// 2.双指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; len &amp;&amp; arr[left] &lt; arr[left + <span class="number">1</span>]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; arr[right] &lt; arr[right - <span class="number">1</span>]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left == right &amp;&amp; left != <span class="number">0</span> &amp;&amp; right != len - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1207-独一无二的出现次数"><a href="#1207-独一无二的出现次数" class="headerlink" title="1207.独一无二的出现次数"></a>1207.独一无二的出现次数</h3><p>使用map记录每一个元素的出现次数，最后依次把出现次数放到set当中，如果set已经存在这个次数了就返回false</p>
<h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 双指针法，fast遍历数组，如果fast位置不是0，那就直接赋值给slow，最后slow没走完的位置都是0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> slow; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a>189. 旋转数组</h3><p>1.倒序前len-k个元素，倒序后k个元素，倒序整个数组</p>
<p>2.双指针：右轮转k次，每一次轮转都有：记录nums[0], slow&#x3D;0, fast&#x3D;slow+1, nums[slow]&#x3D;nums[fast]</p>
<p>3.暴力解法，O(n)的空间，先把后k个元素复制到新的数组当中，再把剩下的复制</p>
<h3 id="724-寻找数组的中心下标"><a href="#724-寻找数组的中心下标" class="headerlink" title="724.寻找数组的中心下标"></a>724.寻找数组的中心下标</h3><p>遍历数组求出总和，第二次遍历再计算leftSum和rightSum是否相等。</p>
<p>其中，leftSum的定义是从0到i为止(包括i的sum)，rightSum也是包括i的sum。这样可以少很多特殊条件的判断</p>
<h3 id="922-按奇偶排序数组II"><a href="#922-按奇偶排序数组II" class="headerlink" title="922. 按奇偶排序数组II"></a>922. 按奇偶排序数组II</h3><p>双指针，slow只关心偶数位置，fast只关心奇数位置</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h3><p><strong>这类问题最重要的是在草稿上画出节点变动的过程，否则写起来会很麻烦。以及需要注意，while的条件到底是 cur!&#x3D;null 还是 cur.next!&#x3D;null ，以及遇到 cur.next.next 的时候要注意判断 cur.next&#x3D;&#x3D;null。</strong></p>
<p>这道题比较简单，需要注意删除cur节点的时候，pre和cur的处理。以及要新建结果链表的新的头节点result，因为结果链表的头节点有可能不是head</p>
<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><p>这道题比较简单，头插法：cur摘掉（cur一直在head后面），插在result和result.next中间</p>
<h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p>这道题需要对每两个一组的cur1，cur2以及pre的操作在草稿上面画的清楚。并且需要注意，一开始pre的定义是pre.next&#x3D;head，那么要把这个时候pre的位置记下来，返回这个位置的next才是最后的头节点</p>
<h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h3><p>快慢指针，快指针比慢指针先走N-1个位置，fast走到最后的时候，slow就是倒数N个节点，再记录slow前一个节点pre，通过pre吧slow删除</p>
<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h3><p>快慢指针，在短链表里面的慢指针每次走一步，从头节点开始走。在长链表里面的快指针每次走一步，但是从第abs(m-n)个节点开始走</p>
<h3 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h3><p>快慢指针，快指针走两步，慢指针走一步。当快慢相遇的时候，再派一个慢指针slow2，slow2和slow1相遇的位置就是入口</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h3><p><strong>什么时候使用哈希法</strong>，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</p>
<p>使用数组存储26个字母的出现频率，构造简易的哈希表</p>
<h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h3><p>输出结果中的每个元素一定是唯一的，所以考虑HashSet当作哈希表</p>
<h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202.快乐数"></a>202.快乐数</h3><p>不符合要求的n会无限循环，也就是结果会重复出现。因此需要使用set来记录每一次的结果，如果重复出现了就不是快乐数</p>
<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><p>1.排序+快慢指针</p>
<p>2.数组中同一个元素在答案里不能重复出现，想到使用HashMap。这里需要注意，为什么不是HashSet呢，因为我们最后需要返回元素的下标，那么哈希表就需要存放元素和下标位置，使用HashMap可以轻松解决。</p>
<p>并且需要注意的是，我们需要在哈希表当中寻找元素是否出现过，那么key得是元素。</p>
<h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><p>使用数组存储26个字母的出现频率，构造简易的哈希表即可</p>
<h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h3><p>先排序，固定slow1，对接下来的数组使用快慢指针来寻找target&#x3D;&#x3D;0-nums[slow1]的两个元素</p>
<p>需要注意的是，答案返回组成三元组的元素数值，并且当中不可以有重复的三元组，那么就需要去重：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">如果slow1和slow1-<span class="number">1</span>一样，那么slow1-<span class="number">1</span>的位置可以确保一定被考虑过，所以要判断的是slow1-<span class="number">1</span>和slow1</span><br><span class="line"><span class="title function_">while</span> <span class="params">(slow1 - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; slow1 &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[slow1] == nums[slow1 - <span class="number">1</span>])</span>&#123;</span><br><span class="line">    slow1++;</span><br><span class="line">&#125;</span><br><span class="line"> 此时slow2和fast已经处理过了，要看接下来的slow2+<span class="number">1</span>和fast-<span class="number">1</span>是否还和slow2/fast一样</span><br><span class="line"><span class="keyword">while</span> (slow2 + <span class="number">1</span> &lt; fast &amp;&amp; nums[slow2] == nums[slow2 + <span class="number">1</span>]) &#123;</span><br><span class="line">    slow2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (slow2 &lt; fast - <span class="number">1</span> &amp;&amp; nums[fast] == nums[fast - <span class="number">1</span>]) &#123;</span><br><span class="line">    fast--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：Set无法直接去重，因为<code>list1:&#123;1,2,3&#125;</code>和<code>list2:&#123;2,1,3&#125;</code>不会被认为是重复的</p>
<h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h3><p>对于去重的操作如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i + <span class="number">1</span> &lt;= nums.length - <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">while</span> (j - <span class="number">1</span> &gt;= i + <span class="number">1</span> &amp;&amp; j + <span class="number">1</span> &lt;= nums.length - <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br><span class="line"> 此时slow和fast已经处理过了，要看接下来的slow+<span class="number">1</span>和fast-<span class="number">1</span>是否还和slow/fast一样</span><br><span class="line"><span class="keyword">while</span> (slow + <span class="number">1</span> &lt; fast &amp;&amp; nums[slow] == nums[slow + <span class="number">1</span>]) &#123;</span><br><span class="line">    slow++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">while</span> (slow &lt; fast - <span class="number">1</span> &amp;&amp; nums[fast] == nums[fast - <span class="number">1</span>]) &#123;</span><br><span class="line">    fast--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，这道题可能会涉及到int溢出的问题，所以要强转成long：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">myTarget</span> <span class="operator">=</span> target - (<span class="type">long</span>) nums[i] - (<span class="type">long</span>) nums[j];</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">long</span>) nums[slow] + nums[fast] == myTarget)</span><br></pre></td></tr></table></figure>

<h3 id="454-四数相加II"><a href="#454-四数相加II" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h3><p>三数之和和四数之和这两道题目使用哈希法在不超时的情况下做到对结果去重是很困难的，有很多细节需要处理。这道题和三数相加、四数相加的思路都不一样，是使用哈希法的经典题目，应该使用HashMap。</p>
<p>思路是：统计两个数组AB中的元素之和，同时统计出现的次数，放入map。再统计剩余的两个元素CD的和，在map中找是否存在相加为0的情况，同时记录次数。</p>
<h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><p>使用左右指针即可</p>
<h3 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541. 反转字符串II"></a>541. 反转字符串II</h3><p>这道题需要稍微注意以下两个条件的判断即可：</p>
<ul>
<li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li>
<li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li>
</ul>
<p>以及String对象一旦创建，实体是不可以变化的，即内容不能再修改。所以应该将String转成char[]再操作</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><p>动态规划中每一个状态一定是由上一个状态推导出来的，而贪心是局部直接选最优的。</p>
<h4 id="动态规划方法论："><a href="#动态规划方法论：" class="headerlink" title="动态规划方法论："></a><strong>动态规划方法论：</strong></h4><ul>
<li>确定dp[i]数组的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li><del>举例推导dp数组</del></li>
</ul>
<p>写动规题目，代码出问题很正常！<strong>找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p>
<p><strong>01背包：</strong></p>
<p>1.dp[i] [j]：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</p>
<p>2.dp[i] [j] &#x3D; max ( dp[i - 1] [j]不加入物品i ,  dp[i - 1] [j - weight[i]] + value[i] 加入了物品i );</p>
<p>3.dp[0] [j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p>
<p>那么很明显当 j &lt; weight[0]的时候，dp[0] [j] 应该是 0，因为背包容量比编号0的物品重量还小。</p>
<p>当j &gt;&#x3D; weight[0]时，dp[0] [j] 应该是value[0]，因为背包容量放足够放编号0物品。</p>
<p>如果背包容量j为0的话，即dp[i] [0]，无论是选取哪些物品，背包价值总和一定为0。</p>
<p>4.从推导公式可以看出，每一次dp[i] [j]的确定都需要dp[i - 1] [j]和dp[i - 1] [j - weight[i]]的确定，都在左上角和正上方的方向，所以先i（物品）后j（容量），或者先j后i都可以，<strong>推荐使用先i物品后j容量，更加符合我们平时的习惯，而且一定不会错。</strong></p>
<h4 id="进阶：把二维压缩成一维数组："><a href="#进阶：把二维压缩成一维数组：" class="headerlink" title="进阶：把二维压缩成一维数组："></a><strong>进阶：把二维压缩成一维数组：</strong></h4><p>在使用二维数组的时候，递推公式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure>

<p><strong>其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i] [j] &#x3D; max(dp[i] [j], dp[i] [j - weight[i]] + value[i]);</strong></p>
<p><strong>与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了</strong>，只用dp[j]（一维数组，也可以理解是一个滚动数组）。</p>
<p>1.dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p>
<p>2.那么递推公式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure>

<p>3.dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p>
<p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？</p>
<p>看一下递归公式：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p>
<p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p>
<p>那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p>
<p>4.遍历顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p>
<p>举一个例子：物品0的重量weight[0] &#x3D; 1，价值value[0] &#x3D; 15</p>
<p>如果正序遍历</p>
<p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p>
<p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 30</p>
<p>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p>
<p>为什么倒序遍历，就可以保证物品只放入一次呢？</p>
<p>倒序就是先算dp[2]</p>
<p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 15 （dp数组已经都初始化为0）</p>
<p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p>
<p><strong>再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？</strong></p>
<p>不可以！</p>
<p>因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。</p>
<p>倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。</p>
<h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a><strong>完全背包</strong></h4><p>而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中i和j的嵌套顺序是可以改变的</p>
<p><strong>注意！任何一个问题当中，有限的资源&#x2F;要达到的限制条件是背包的容量，最大化的目标是背包的价值</strong></p>
<h4 id="完全背包的进阶：排列组合问题"><a href="#完全背包的进阶：排列组合问题" class="headerlink" title="完全背包的进阶：排列组合问题"></a>完全背包的进阶：排列组合问题</h4><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong></p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong></p>
<p>具体说明：</p>
<p>我们先来看 外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; coins.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coins[i]; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设：coins[0] &#x3D; 1，coins[1] &#x3D; 5。</p>
<p>那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。</p>
<p><strong>所以这种遍历顺序中dp[j]里计算的是组合数！</strong></p>
<p>如果把两个for交换顺序，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; coins.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j - coins[i] &gt;= <span class="number">0</span>) dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。</p>
<p><strong>此时dp[j]里算出来的就是排列数！</strong></p>
<h3 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h3><p>1.dp[i]&#x3D;斐波那契i位置的数值</p>
<p>2.dp[i]&#x3D;dp[i-1]+dp[i-2]</p>
<p>3.dp[0]&#x3D;0,dp[1]&#x3D;1</p>
<p>4.从左到右遍历</p>
<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h3><p>1.dp[i]爬到i阶梯有多少方法爬到</p>
<p>2.dp[i]&#x3D;dp[i-1]+dp[i-2]</p>
<p>3.dp[0]&#x3D;1 dp[1]&#x3D;1</p>
<p>4.从左到右遍历</p>
<h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h3><p>1.dp[i]是爬到楼梯i的最小花费</p>
<p>2.dp[i]&#x3D;min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])</p>
<p>3.dp[0]&#x3D;0 dp[1]&#x3D;0</p>
<p>4.从左到右遍历</p>
<h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h3><p>1.dp[i] [j]到达(i,j)位置有多少路径</p>
<p>2.dp[i] [j]&#x3D;dp[i-1] [j]+dp[i] [j-1]</p>
<p>3.dp[0] [j]&#x3D;1 dp[i] [0]&#x3D;1</p>
<p>4.从左到右，从上到下</p>
<h3 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a>63. 不同路径 II</h3><p>1.dp[i] [j]为到达i,j位置的路径总数</p>
<p>2.dp[i] [j]&#x3D;dp[i-1] [j]+dp[i] [j-1] dp[障碍物]&#x3D;0</p>
<p>3.dp[0] [j]&#x3D;1(如果这一列都没有障碍物，否则在障碍物之后都是0) dp[i] [0]&#x3D;1（同理）</p>
<p>4.从左向右，从上向下</p>
<h3 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a>343. 整数拆分</h3><p>1.dp[i]表示拆分数字i可以获得的最大乘积</p>
<p>2.dp[i]&#x3D;max(dp[i-1]×1 , dp[i-2]×2 , , , , dp[1]×(i-1) , (i-1)×1 , (i-2)×2 , , , 1×i)</p>
<p>这里需要注意：&#x3D;&#x3D;j * (i - j) 是单纯的把整数拆分为两个数相乘&#x3D;&#x3D;，而 j * dp[i - j]是拆分成两个以及两个以上的个数相乘</p>
<p>3.dp[1]&#x3D;1</p>
<p>4.i从左到右</p>
<h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.不同的二叉搜索树</h3><p>1.dp[i]是i个节点构成的二叉树的个数</p>
<p>2.把任何一个由i个节点构成的二叉树都看成是左+右子树，左子树可以有的节点是0到i-1个，右子树也同理，该树的构成种类是左子树构成种类*右子树构成种类。dp[i]&#x3D;sum( dp[i-1]×dp[0] , dp[i-2]×dp[1] , , , , )</p>
<p>3.dp[0]&#x3D;1</p>
<p>4.i从小到大</p>
<h3 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h3><p>01背包问题，背包的容量是sum&#x2F;2。每个数字的价值是num[j]，每个数字占有容量nums[j]，最后查看sum&#x2F;2&#x3D;&#x3D;nums[sum&#x2F;2]</p>
<p>1.dp[j]是背包容量为j的背包，可以获得的最多的价值</p>
<p>2.dp[j]&#x3D;max(dp[j],dp[j-nums[i]]+nums[i])</p>
<p>3.dp[j]都是0</p>
<p>4.i从小到大，j从大到小</p>
<h3 id="1049-最后一块石头的重量II"><a href="#1049-最后一块石头的重量II" class="headerlink" title="1049.最后一块石头的重量II"></a>1049.最后一块石头的重量II</h3><p>转化成sum&#x2F;2的01背包问题，最后返回sum - 2 * dp[dp.length - 1]</p>
<p>1.dp[i]表示容量为i的背包装下的最大值</p>
<p>2.递推公式是dp[i]&#x3D;max(dp[i],dp[i-weight]+weight)</p>
<p>3.初始化都是0 </p>
<p>4.递推顺序是stone正向,背包反向</p>
<h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h3><p>1.dp[i]表示组成数字i的完全平方数的最小的数量</p>
<p>2.dp[i]&#x3D;min(dp[i-1],dp[i-4],,,,)+1</p>
<p>3.dp[小于n的完全平方数]&#x3D;1</p>
<p>4.i从小到大</p>
<h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h3><p>1.dp[i] [0]表示第i天是不持有股票的状态，所具有的资金</p>
<p>dp[i] [1]表示的是持有股票的状态所具有的资金，初始资金是0</p>
<p>2.dp[i] [0]&#x3D;max(dp[i-1] [1]+prices[i],dp[i-1] [0])</p>
<p>dp[i] [1]&#x3D;max(-prices[i],dp[i-1] [1])，题里面只要求买卖一次，所以无论何时购买，资金都是-prices[i]</p>
<p>3.dp[0] [0]&#x3D;0 dp[0] [1]&#x3D;-prices[0]</p>
<p>4.i从左到右</p>
<h3 id="122-买卖股票的最佳时机II"><a href="#122-买卖股票的最佳时机II" class="headerlink" title="122.买卖股票的最佳时机II"></a>122.买卖股票的最佳时机II</h3><p>1.dp[i] [0]表示第i天不持有股票所持有的最大资金</p>
<p>dp[i] [1]表示第i天持有股票所持有的最大资金</p>
<p>2.dp[i] [0]&#x3D;max(dp[i-1] [0] , dp[i-1] [1]+prices[i])</p>
<p>dp[i] [1]&#x3D;max(dp[i-1] [1],dp[i-1] [0]-prices[i])</p>
<p>3.dp[0] [0]&#x3D;0 dp[0] [1]&#x3D;-prices[0]</p>
<p>4.i从小到大</p>
<h3 id="123-买卖股票的最佳时机III"><a href="#123-买卖股票的最佳时机III" class="headerlink" title="123.买卖股票的最佳时机III"></a>123.买卖股票的最佳时机III</h3><p>1.dp[i] [0]第i天不持有股票，1第一次持有股票，2第一次不持有股票，3第二次持有股票，4第二次不持有股票</p>
<p>2.dp[i] [0]&#x3D;dp[i-1] [0]</p>
<p>dp[i] [1]&#x3D;max(dp[i-1] [1],dp[i-1] [0]-prices[i])</p>
<p>dp[i] [2]&#x3D;max(dp[i-1] [2],dp[i-1] [1]+prices[i])</p>
<p>dp[i] [3]&#x3D;max(dp[i-1] [3],dp[i-1] [2]-prices[i])</p>
<p>dp[i] [4]&#x3D;max(dp[i-1] [4],dp[i-1] [3]+prices[i])</p>
<p>3.dp[0] [0]&#x3D;0 dp[0] [1]&#x3D;-prices[0] dp[0] [2]&#x3D;0 dp[0] [3]&#x3D;-prices[0] dp[0] [4]&#x3D;0</p>
<p>4.i从小到大</p>
<h3 id="188-买卖股票的最佳时机IV"><a href="#188-买卖股票的最佳时机IV" class="headerlink" title="188.买卖股票的最佳时机IV"></a>188.买卖股票的最佳时机IV</h3><p>1.dp[i] [0]是第i天不持有股票，1是第一次持有，2是第一次不持有，，，</p>
<p>2.dp[i] [0]&#x3D;dp[i-1] [0]</p>
<p>dp[i] [2×k+1]&#x3D;max(dp[i] [2×k]-prices[i],dp[i-1] [2×k+1])</p>
<p>dp[i] [2×k+2]&#x3D;max(dp[i] [2×k+1]+prices[i],dp[i-1] [2×k+2])</p>
<p>3.dp[0] [2×k+1]&#x3D;-prices[0]          </p>
<p>dp[0] [2×k]&#x3D;0</p>
<p>4.i从小到大</p>
<h3 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714.买卖股票的最佳时机含手续费"></a>714.买卖股票的最佳时机含手续费</h3><p>1.dp[i] [0]在第i天不持有股票所拥有的资金，1持有</p>
<p>2.dp[i] [0]&#x3D;max(dp[i-1] [0],dp[i-1] [1]+prices[i]-fee)</p>
<p>dp[i] [1]&#x3D;max(dp[i-1] [1],dp[i-1] [0]-prices[i])</p>
<p>3.dp[0] [0]&#x3D;0 </p>
<p>dp[0] [1]&#x3D;-prices[0]</p>
<p>4.i从小到大</p>
<h3 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a>647. 回文子串</h3><p>1.dp[i] [j]表示s当中[i,j]是否是回文串</p>
<p>2.dp[i] [j]&#x3D; 0(false)；</p>
<p>1(true)当且仅当s[i]&#x3D;s[j]&amp;&amp;dp[i+1] [j-1]&#x3D;true，或j&#x3D;i+1的时候s[i]&#x3D;&#x3D;s[j]也可以（“aa”）</p>
<p>3.dp[i] [i]&#x3D;1</p>
<p>4.根据递推公式可以得出，dp[i] [j]根据左下角的值dp[i+1] [j-1]，j从左往右，i从下往上</p>
<h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h3><p>1.dp[i]表示截止到第i家位置所获得的最大金额</p>
<p>2.dp[i]&#x3D;max(dp[i-2]+nums[i],dp[i-1])</p>
<p>3.dp[0]&#x3D;nums[0] dp[1]&#x3D;max(nums[0],nums[1])</p>
<p>4.i从小到大</p>
<h3 id="213-打家劫舍II"><a href="#213-打家劫舍II" class="headerlink" title="213.打家劫舍II"></a>213.打家劫舍II</h3><p>1.dp[i]表示截止到第i家位置所获得的最大金额</p>
<p>2.dp[i]&#x3D;max(dp[i-2]+nums[i],dp[i-1])</p>
<p>3.dp[0]&#x3D;nums[0] dp[1]&#x3D;max(nums[0],nums[1])</p>
<p>4.&#x3D;&#x3D;i考虑首元素不考虑尾元素来一遍打劫，考虑尾元素不考虑首元素来一遍打劫&#x3D;&#x3D;</p>
<h3 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337.打家劫舍 III"></a>337.打家劫舍 III</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 后序遍历，每一个节点的遍历都存储维护一个dp数组，是树形的动态规划</span></span><br><span class="line">        <span class="comment">// dp[0]表示不抢当前节点，dp[1]表示抢当前节点</span></span><br><span class="line">        <span class="comment">// dp[0]=max(left[0],left[1])+max(right[0],right[1])</span></span><br><span class="line">        <span class="comment">// dp[1]=cur.val+left[0]+right[0]</span></span><br><span class="line">        <span class="comment">// cur==null,return [0,0]</span></span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        <span class="type">int</span>[] dp = robNode(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] robNode(TreeNode cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] left = robNode(cur.left);</span><br><span class="line">        <span class="type">int</span>[] right = robNode(cur.right);</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">1</span>] = cur.val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a>376. 摆动序列</h3><p>1.dp[i]表示截止到i位置，当前的摆动序列的最长子序列的长度，[0]表示i作为低位置，[1]表示i作为高位置</p>
<p>2.dp[i] [0]&#x3D;(nums[i]&lt;nums[i-1])dp[i-1][1]+1 else dp[i-1][0]</p>
<p>dp[i] [1]&#x3D;(nums[i]&gt;nums[i-1])dp[i-1][0]+1 else dp[i-1][1]</p>
<p>3.dp[0] [0]&#x3D;1 dp[0] [1]&#x3D;1</p>
<p>4.i从小到大</p>
<h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h3><p>1.dp[i]表示截止到i位置(包括i位置)，连续子数组的最大和</p>
<p>2.dp[i]&#x3D;max(dp[i-1]+nums[i],nums[i])</p>
<p>3.dp[0]&#x3D;nums[0]</p>
<p>4.i从小到大</p>
<p>注意根据dp[i]的定义，最终结果应该是dp当中的max，而不是dp[len-1]</p>
<h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a>300.最长递增子序列</h3><p><strong>dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度</strong></p>
<p>为什么一定表示 “以nums[i]结尾”的最长递增子序，因为我们在做递增比较的时候，如果比较 nums[j] 和 nums[i] 的大小，那么两个递增子序列一定分别以nums[j]为结尾 和 nums[i]为结尾， 要不然这个比较就没有意义了，不是尾部元素的比较那么如何可以算作递增呢。</p>
<p>1.dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度</p>
<p>2.dp[i]&#x3D;(for j&lt;i if(num[j]&lt;num[i]){dp[i]&#x3D;max(dp[j])+1;})</p>
<p>3.dp[i]&#x3D;1</p>
<p>4.i从小到大</p>
<h3 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a>674. 最长连续递增序列</h3><p>1.dp[i]表示截至到i位置最长的连续递增子序列（包括i位置）</p>
<p>2.dp[i]&#x3D;(nums[i]&gt;nums[i-1] dp[i-1]+1) else 1</p>
<p>3.dp[0]&#x3D;1</p>
<p>4.i从小到大</p>
<h3 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143.最长公共子序列"></a>1143.最长公共子序列</h3><p>1.dp[i] [j]表示text1的i为止和text2的j为止，最长的公共子序列长度</p>
<p>2.dp[i] [j]&#x3D;dp[i-1] [j-1]+1(text1[i]&#x3D;&#x3D;text2[j])&#x2F;max(dp[i-1] [j],dp[i] [j-1])</p>
<p>3.dp[0] [j]&#x3D;0,等到text1[0]&#x3D;&#x3D;text2[j]之后都是1,dp[i] [0]也是同理</p>
<p>4.i从小到大，j从小到大</p>
<h3 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="1035.不相交的线"></a>1035.不相交的线</h3><p>线的个数就是最长公共子序列的长度，这道题同1143题</p>
<h3 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a>718. 最长重复子数组</h3><p>1.dp[i] [j]表示nums1到i为止，nums2到j为止，最长的公共子数组长度(子数组都是连续的)</p>
<p>2.dp[i] [j]&#x3D;dp[i-1] [j-1]+1(nums1[i]&#x3D;&#x3D;nums2[j])，dp[i][j]只能通过这种方式累计</p>
<p>3.dp[0] [j]只有nums1[0]&#x3D;&#x3D;nums2[j]才是1</p>
<p>4.i从小到大，j从小到大</p>
<h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494.目标和"></a>494.目标和</h3><p>target&#x3D;x-(sum-x),x&#x3D;(target+sum)&#x2F;2,x是背包的容量</p>
<p>把问题转化成容量为x的背包，装满这个背包的方法有多少</p>
<p>1.dp[j]为把容量为i的背包装满的方式个数</p>
<p>2.dp[j]&#x3D;+dp[j-nums[i]]</p>
<p>3.dp[0]&#x3D;1</p>
<p>4.i正向，j逆向</p>
<h3 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474.一和零"></a>474.一和零</h3><p>1.dp[i] [j]表示对0是容量m，对1是容量n的背包可以最多装多少字符串</p>
<p>2.dp[i] [j]&#x3D;max(1+dp[i-char0[k]] [j-char1[k]],dp[i] [j])</p>
<p>3.dp[0] [0]&#x3D;0</p>
<p>4.i,j都倒序，k遍历字符串在最外面正序</p>
<h3 id="518-零钱兑换II"><a href="#518-零钱兑换II" class="headerlink" title="518.零钱兑换II"></a>518.零钱兑换II</h3><p>完全背包问题</p>
<p>1.dp[j]表示容量为j的背包装满的方式有多少</p>
<p>2.dp[j]+&#x3D;dp[j-coins[i]]</p>
<p>3.dp[0]&#x3D;1</p>
<p>4.i遍历硬币正向，j遍历背包容量正向</p>
<h3 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a>377. 组合总和 Ⅳ</h3><p>完全背包</p>
<p>1.dp[j]表示容量为j的背包可以装满的方式个数</p>
<p>2.dp[j]+&#x3D;dp[j-nums[i]]</p>
<p>3.dp[0]&#x3D;1</p>
<p>4.i正向遍历数字在里面，j正向遍历背包在外面</p>
<p>如果求组合数就是外层for循环遍历物品，内层for遍历背包</p>
<p>如果求排列数就是外层for遍历背包，内层for循环遍历物品</p>
<h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h3><p>完全背包问题</p>
<p>1.dp[j]表示装满容量为j的背包的所需要的最小的硬币个数</p>
<p>2.dp[j]&#x3D;min(dp[j],dp[j-coins[i]]+1),dp[0]&#x3D;0</p>
<p>3.dp[j]都初始化成amount+1</p>
<p>4.i正向外面，j正向里面</p>
<h3 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309.最佳买卖股票时机含冷冻期"></a>309.最佳买卖股票时机含冷冻期</h3><p>1.dp[i]表示第i天：0不持有股票且不在冷静期，1不持有股票且在冷静期，2持有股票</p>
<p>2.dp[i] [0]&#x3D;max(dp[i-1] [0],dp[i-1] [1])</p>
<p>dp[i] [1]&#x3D;dp[i-1] [2]+prices[i]</p>
<p>dp[i] [2]&#x3D;max(dp[i-1] [0]-prices[i],dp[i-1] [2])</p>
<p>3.dp[0] [0]&#x3D;0,dp[0] [1]&#x3D;0,dp[0] [2]&#x3D;-prices[0]</p>
<p>4.i从1开始</p>
<h3 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392.判断子序列"></a>392.判断子序列</h3><p><strong>即判断s和t的最长公共子序列的长度是否为s的长度即可</strong></p>
<p>1.dp[i] [j]表示s考虑到i为止，t考虑到j位置的最长公共子序列的长度</p>
<p>2.dp[i] [j]&#x3D;dp[i-1] [j-1]+1(s.charAt(i)&#x3D;&#x3D;t.charAt(j)) &#x2F; Math.max(dp[i] [j-1],dp[i-1] [j])</p>
<p>3.dp[0] [j]&#x3D;1(s.charAt(0)&#x3D;&#x3D;t.charAt(j)及以后),dp[i] [0]同理</p>
<p>4.i正向，j正向</p>
<h3 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115.不同的子序列"></a>115.不同的子序列</h3><p><strong>s是t的子序列 &lt;&#x3D;&gt; t删除一些字符之后就是s</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// dp[i][j]表示s考虑到i为止，t考虑到j为止，s当中t出现的个数</span></span><br><span class="line">        <span class="comment">// if(s.charAt(i)==t.charAt(j)) dp[i][j]=dp[i-1][j]+dp[i-1][j-1]</span></span><br><span class="line">        <span class="comment">// 开始解释</span></span><br><span class="line">        <span class="comment">// dp[i-1][j]相当于是s考虑到i-1&amp;t考虑到j,dp[i-1][j-1]相当于是s考虑到i-1&amp;t考虑到j-1</span></span><br><span class="line">        <span class="comment">// 当s[i]等于t[j]的时候，那么dp[i][j]可以由以上两种情况得到</span></span><br><span class="line">        <span class="comment">// (因为已经由s[i]==t[j]了，那么我们可以把t[j]位置删除来匹配)</span></span><br><span class="line">        <span class="comment">// 解释完毕</span></span><br><span class="line">        <span class="comment">// else dp[i][j]=dp[i-1][j]</span></span><br><span class="line">        <span class="comment">// dp[i][0]=累积到目前s.charAt(i)==t.charAt(0)的个数</span></span><br><span class="line">        <span class="comment">// dp[0][j]是s只考虑第一个字符的情况下，t是否是s的子序列，所以除了dp[0][0]以外dp[0][j]肯定全是0</span></span><br><span class="line">        <span class="comment">// i正向，j正向</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> t.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len1][len2];</span><br><span class="line">        <span class="type">char</span> <span class="variable">s0</span> <span class="operator">=</span> s.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">t0</span> <span class="operator">=</span> t.charAt(<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = (s0 == t0) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len1; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">cur</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur == t0) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; len2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == t.charAt(j)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1 - <span class="number">1</span>][len2 - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a>583. 两个字符串的删除操作</h3><p>1.dp[i] [j]表示word1考虑到i位置，word2考虑到j位置，使得word1和word2相同所需的最少删除次数</p>
<p>2.if(word1.charAt(i)&#x3D;&#x3D;word2.charAt(j)) dp[i] [j]&#x3D;dp[i-1] [j-1]</p>
<p>else dp[i] [j]&#x3D;min(dp[i-1] [j]+1(删除word1的i位置),</p>
<p>dp[i] [j-1]+1(删除word2的j位置),</p>
<p>dp[i-1] [j-1]+2(删除word1的i位置和word2的j位置，其实这一项是多余的，前两项可以覆盖这个情况))</p>
<p>3.dp[i] [0]是word1考虑到i和word2第一个字符的最小删除操作,dp[0] [j]同理</p>
<p>4.i正向，j正向</p>
<h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h3><p>1.dp[i] [j]表示word1考虑到i为止，word2考虑到j为止，最少的操作数</p>
<p>2.if(word1.charAt(i)&#x3D;&#x3D;word2.charAt(j)) dp[i] [j]&#x3D;dp[i-1] [j-1]</p>
<p>else dp[i] [j]&#x3D;min</p>
<p>增：不需要额外考虑，对word1的删除，就是对word2的添加，因此删除和添加的操作是等价的</p>
<p>删：删除i位置，dp[i-1] [j]+1；删除j位置，dp[i] [j-1]+1；删除i和j位置都被包括了，可以不考虑了</p>
<p>换：把i位置换成和j一样的(反过来也一样)，那么if(word1.charAt(i)&#x3D;&#x3D;word2.charAt(j))成立，所以dp[i-1] [j-1]+1</p>
<p>3.dp[0] [j]表示word1第一个字符和word2考虑到j为止，最小的操作数</p>
<p>如果0位置和j相等，dp[0] [j]&#x3D;j(j这个位置不动，其他位置都要删除)，</p>
<p>如果不相等，dp[0] [j]&#x3D;j+1(如果目前为止没有一个位置和0位置相等) or</p>
<p>j(否则，删除其他j个位置，只保留和0位置相等的那个地方)</p>
<p>dp[i] [0]同理</p>
<p>4.i正向，j正向</p>
<h3 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516.最长回文子序列"></a>516.最长回文子序列</h3><p>1.dp[i] [j]表示i到j的最长回文子序列的长度</p>
<p>2.dp[i] [j]&#x3D;(if s.charAt(i)&#x3D;&#x3D;s.charAt(j))dp[i+1] [j-1]+2</p>
<p>else max(dp[i-1] [j],dp[i] [j-1])</p>
<p>3.dp[i] [i]&#x3D;1</p>
<p>4.i逆向，j正向</p>
<h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="comment">// 双指针+dp：</span></span><br><span class="line">        <span class="comment">// leftDp[i]表示考虑到位置i，左边的最高柱子</span></span><br><span class="line">        <span class="comment">// leftDp[i]=max(leftDp[i-1],height[i])</span></span><br><span class="line">        <span class="comment">// leftDp[0]=height[0]</span></span><br><span class="line">        <span class="comment">// leftDp从左到右</span></span><br><span class="line">        <span class="comment">// rightDp同理，表示右边的最高柱子</span></span><br><span class="line">        <span class="comment">// size+=min(leftDp[i],rightDp[i])-height[i]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span>[] leftDp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span>[] rightDp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        rightDp[len - <span class="number">1</span>] = height[len - <span class="number">1</span>];</span><br><span class="line">        leftDp[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            leftDp[i] = Math.max(leftDp[i - <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            rightDp[i] = Math.max(rightDp[i + <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            size += Math.min(leftDp[i], rightDp[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><p>构建一个栈，只有栈顶是左括号，要加入的是右括号的时候，让栈弹出，否则就push进去。最后查看栈是否是空栈</p>
<h3 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h3><p>构建一个栈，只有栈顶元素和要加入的元素相同的时候，让栈弹出，否则就push进去。也可以使用快慢指针（转成字符数组，用快指针处的元素覆盖慢指针处的怨怒是），或者直接在字符串上进行修改（转成StringBuilder或者StringBuffer，直接删除元素）</p>
<h3 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h3><p>遇到加减乘除就连续pop两次，计算结果之后再压栈</p>
<h3 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 先使用MAP记录每一个元素的出现频率，再使用大顶堆来存储元素，按照频率排序，poll前k个元素</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; me = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            me.put(nums[i], me.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; qu = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o2[<span class="number">1</span>] - o1[<span class="number">1</span>]);<span class="comment">// 根据int[]位置1，也就是频率建立大顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : me.keySet()) &#123;</span><br><span class="line">            qu.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; num, me.get(num) &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            result[i] = qu.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a>455.分发饼干</h3><p>把最大的饼干给最饿的孩子，如果满足不了最饿的孩子，就给第二饿的孩子</p>
<h3 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860.柠檬水找零"></a>860.柠檬水找零</h3><p>只需要记录5的零钱个数，和10的零钱个数即可。需要注意，给20找零15元的时候，有两种找零方式：10+5或者5*3</p>
<h3 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a>135. 分发糖果</h3><p>动态规划:</p>
<p>1.dp[i]表示第i个孩子分到多少糖</p>
<p>2.dp[i]&#x3D;if(ratings[i]&gt;ratings[i-1])dp[i-1]+1 else 1</p>
<p>3.dp[i]&#x3D;1,dp[0]和dp[1]单独赋值</p>
<p>4.i从小到大来一遍，从大到小来一遍</p>
<h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.从左到右遍历，把能够到达的位置全部标记上</span></span><br><span class="line">        <span class="comment">// 如果要改进的话，标记位置不需要new一个数组，记录最远的位置即可</span></span><br><span class="line">        <span class="comment">// int[] me = new int[nums.length];</span></span><br><span class="line">        <span class="comment">// me[0] = 1;</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; me.length; i++) &#123;</span></span><br><span class="line">        <span class="comment">// for (int j = i + 1; j &lt; i + 1 + nums[i] &amp;&amp; j &lt; me.length; j++) &#123;</span></span><br><span class="line">        <span class="comment">// me[j] = 1;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if (me[i] == 0) &#123;</span></span><br><span class="line">        <span class="comment">// return false;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return true;</span></span><br><span class="line">        <span class="comment">// 2.从最后一个位置推能不能回到初始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &lt; target - i) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            target = i;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1005-K次取反后最大化的数组和"><a href="#1005-K次取反后最大化的数组和" class="headerlink" title="1005.K次取反后最大化的数组和"></a>1005.K次取反后最大化的数组和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 要先从最小的负值元素翻转一次，如果还留有剩余，那就继续翻转其他负值的元素</span></span><br><span class="line">        <span class="comment">// 如果负值翻转完毕，就只对最小的正值元素一直翻转</span></span><br><span class="line">        <span class="comment">// 因此按照绝对值的从小到大开始排列，从后往前依次翻转负数，如果最后k还有剩余，那就翻转位置0</span></span><br><span class="line">        nums = IntStream.of(nums)</span><br><span class="line">                .boxed()</span><br><span class="line">                .sorted((o1, o2) -&gt; Math.abs(o1) - Math.abs(o2))</span><br><span class="line">                .mapToInt(Integer::intValue).toArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] *= -<span class="number">1</span>;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            nums[<span class="number">0</span>] *= -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            result += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="comment">// 对区间进行排序，当区间有重叠的时候，即ai+1&lt;=bi的时候，射中bi即可，另外还要更新当前区间的最右位置</span></span><br><span class="line">        <span class="comment">// 使用Integer.compare不会溢出</span></span><br><span class="line">        Arrays.sort(points, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span> &lt; points.length &amp;&amp; points[i + <span class="number">1</span>][<span class="number">0</span>] &lt;= points[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                points[i + <span class="number">1</span>][<span class="number">1</span>] = Math.min(points[i + <span class="number">1</span>][<span class="number">1</span>], points[i][<span class="number">1</span>]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a>435. 无重叠区间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="comment">// 这道题和452.很相似，引爆气球的箭的数量其实就是无重叠区间的数量</span></span><br><span class="line">        <span class="comment">// 只有intervals[i][1]&lt;=intervals[i+1][0]的时候，才是不重叠区间</span></span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span> &lt; intervals.length &amp;&amp; intervals[i][<span class="number">1</span>] &gt; intervals[i + <span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">                intervals[i+<span class="number">1</span>][<span class="number">1</span>] = Math.min(intervals[i][<span class="number">1</span>], intervals[i + <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                result++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763.划分字母区间"></a>763.划分字母区间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 记录每一个字母出现的最远的位置</span></span><br><span class="line">        <span class="comment">// i从0开始遍历，考虑i=0的时候，那么第一个片段至少要包括到s[0]的最远位置</span></span><br><span class="line">        <span class="comment">// 并且第一个片段就要考虑到这中间的所有字母，依次更新第一个片段的右区间</span></span><br><span class="line">        <span class="type">int</span>[] me = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        Arrays.fill(me, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            me[c - <span class="string">&#x27;a&#x27;</span>] = Math.max(me[c - <span class="string">&#x27;a&#x27;</span>], i);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length();) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            end = Math.max(end, me[c - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= end) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">                end = Math.max(end, me[d - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(end - start + <span class="number">1</span>);</span><br><span class="line">            start = i;</span><br><span class="line">            end = i;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><h3 id="相关知识-1"><a href="#相关知识-1" class="headerlink" title="相关知识"></a>相关知识</h3><p>回溯本质上是一种纯暴力搜索算法，常用来解决排列组合、子集问题、切割字符串、棋牌问题。</p>
<p><strong>这里注意一定要画出树，再写代码。</strong>树的宽度是回溯处理的集合的大小，树的深度就是递归的深度。</p>
<img src="/2024/07/05/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/20210130173631174.png" class="" title="回溯算法理论基础">

<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(终止条件/叶子节点)&#123;</span><br><span class="line">        收集结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下是单层搜索的逻辑</span></span><br><span class="line">    <span class="keyword">for</span>(集合的元素集)&#123;</span><br><span class="line">        处理每一层的节点;</span><br><span class="line">        递归函数;</span><br><span class="line">        回溯操作/撤销递归的效果;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回溯三部曲：</p>
<p>1.递归函数的参数和返回值</p>
<p>2.终止条件</p>
<p>3.单层递归&#x2F;搜索的逻辑</p>
<h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backtracking(k, n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="comment">// 这里注意，如果直接add(path)，那么增加的都是path对象，而不是path的内容</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n; i++) &#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtracking(k, n, i + <span class="number">1</span>);</span><br><span class="line">            path.remove(Integer.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑剪枝：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backtracking(k, n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="comment">// 这里注意，如果直接add(path)，那么增加的都是path对象，而不是path的内容</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑剪枝，i从start开始，最多只能搜索到n-(k-path.size())+1的位置</span></span><br><span class="line">        <span class="comment">// 其中k-path.size()是还差几个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtracking(k, n, i + <span class="number">1</span>);</span><br><span class="line">            path.remove(Integer.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="216-组合总和III"><a href="#216-组合总和III" class="headerlink" title="216.组合总和III"></a>216.组合总和III</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        backtracking(k, n, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> start, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k &amp;&amp; sum == n) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 剪枝操作</span></span><br><span class="line">            <span class="keyword">if</span> (path.size() + <span class="number">9</span> - i + <span class="number">1</span> &lt; k) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtracking(k, n, i + <span class="number">1</span>, sum + i);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h3><p>这道题需要注意，每一个for处理的都是<strong>每一层的元素的共性操作</strong>，需要注意backtracking的操作要分的清楚：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    String[] me = &#123; <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        backtracking(digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理digits当中第i个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String digits, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= digits.length()) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">String</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> me[digits.charAt(i) - <span class="string">&#x27;2&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; data.length(); j++) &#123;</span><br><span class="line">            path += data.charAt(j) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            backtracking(digits, i + <span class="number">1</span>);</span><br><span class="line">            path = path.substring(<span class="number">0</span>, path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h3><p>可以先使用动态规划把字符串当中所有的回文子串标记上，然后再进行切割和剪枝：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = huiwen(s);</span><br><span class="line">        backtracking(s, <span class="number">0</span>, dp);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切割start开始的子串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span>[][] dp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= s.length()) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[start][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                path.add(s.substring(start, i + <span class="number">1</span>));</span><br><span class="line">                backtracking(s, i + <span class="number">1</span>, dp);</span><br><span class="line">                path.removeLast();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用动态规划判断是否是回文串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] huiwen(String s) &#123;</span><br><span class="line">        <span class="comment">// 1.dp[i][j]表示s的[i,j]的子串是否回文</span></span><br><span class="line">        <span class="comment">// 2.dp[i][j]= i+1==j的时候要判断s[i]==s[j];dp[i+1][j-1]&amp;&amp;s[i]==s[j];</span></span><br><span class="line">        <span class="comment">// 3.dp[i][j]=0,dp[i][i]=1</span></span><br><span class="line">        <span class="comment">// 4.i从下到上，j从左到右</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j == i + <span class="number">1</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="01运算"><a href="#01运算" class="headerlink" title="01运算"></a>01运算</h2><h3 id="1356-根据数字二进制下-1-的数目排序"><a href="#1356-根据数字二进制下-1-的数目排序" class="headerlink" title="1356. 根据数字二进制下 1 的数目排序"></a>1356. 根据数字二进制下 1 的数目排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortByBits(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="comment">// 判断一个数字的二进制有几个1，n=n&amp;(n-1)，几次循环到n==0就是有几位1</span></span><br><span class="line">        <span class="comment">// 原理是n-1会把n当中最后一位1变成0，之后的所有0变成1，按位与之后把最后一个1变成了0</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(arr).boxed().sorted(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer num1, Integer num2)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> count1(num1);</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> count1(num2);</span><br><span class="line">                <span class="keyword">return</span> (a == b) ? Integer.compare(num1, num2) : Integer.compare(a, b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).mapToInt(Integer::intValue).toArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count1</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">            num = num &amp; (num - <span class="number">1</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h3 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h3><p><strong>我们在遍历到i位置的时候，需要查看i之前的元素有没有比i上的元素小的，这就是单调栈的由来。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="comment">// 单调栈</span></span><br><span class="line">        <span class="comment">// 因为要计算位置的差，所以单调栈当中存储的是位置，不是元素</span></span><br><span class="line">        <span class="comment">// 栈顶遇到比它大的元素，就弹栈</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 弹栈</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                result[j] = i - j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 压栈</span></span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把栈的内容都倒出来</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            result[stack.pop()] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496.下一个更大元素 I"></a>496.下一个更大元素 I</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// 导致会有O(mn)的时间复杂度的原因是，nums1[i] == nums2[j]的寻找</span></span><br><span class="line">        <span class="comment">// 为了减少时间复杂度，使用map记录（nums1[i]，i)</span></span><br><span class="line">        <span class="comment">// 单调栈只考虑nums2的元素</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(nums2[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[len1];</span><br><span class="line">        Arrays.fill(result, -<span class="number">1</span>);</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">            map.put(nums1[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; len2) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt; nums2[j]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(num)) &#123;</span><br><span class="line">                    result[map.get(num)] = nums2[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(nums2[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="503-下一个更大元素II"><a href="#503-下一个更大元素II" class="headerlink" title="503.下一个更大元素II"></a>503.下一个更大元素II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElements(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 意味着单调栈需要录入数组两遍</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        Arrays.fill(result, -<span class="number">1</span>);</span><br><span class="line">        stack.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; len * <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[j % len]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                result[num] = nums[j % len];</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(j % len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84.柱状图中最大的矩形"></a>84.柱状图中最大的矩形</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="comment">// 双指针+单调栈：</span></span><br><span class="line">        <span class="comment">// right[i]表示i右侧的第一个更小的元素所在的位置</span></span><br><span class="line">        <span class="comment">// left同理</span></span><br><span class="line">        <span class="comment">// size[i]表示以i位置的高度为基准，形成的矩形的最大面积</span></span><br><span class="line">        <span class="comment">// size[i]=(right[i]-left[i]-1)*heights[i]</span></span><br><span class="line">        <span class="comment">// 最后的结果是在整个size数组当中选个最大的数值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        Arrays.fill(right, len);</span><br><span class="line">        Arrays.fill(left, -<span class="number">1</span>);</span><br><span class="line">        Stack&lt;Integer&gt; rightStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; leftStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!rightStack.isEmpty() &amp;&amp; heights[rightStack.peek()] &gt; heights[i]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> rightStack.pop();</span><br><span class="line">                right[index] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            rightStack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!leftStack.isEmpty() &amp;&amp; heights[leftStack.peek()] &gt; heights[i]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> leftStack.pop();</span><br><span class="line">                left[index] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            leftStack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] size = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            size[i] = (right[i] - left[i] - <span class="number">1</span>) * heights[i];</span><br><span class="line">            System.out.print(size[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            result = Math.max(result, size[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chenghuiwan-cy.github.io">ChengHuiWan-cy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chenghuiwan-cy.github.io/2024/07/05/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/">https://chenghuiwan-cy.github.io/2024/07/05/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://chenghuiwan-cy.github.io" target="_blank">ChengHuiWan-cy的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/leetcode/">leetcode</a></div><div class="post_share"><div class="social-share" data-image="/img/3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/15/%E5%86%8D%E5%86%B2%E4%B8%80%E6%8A%8A/" title="再冲一把"><img class="cover" src="/img/3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">再冲一把</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/27/Docker%E7%9A%84%E4%B8%80%E4%BA%9B%E5%86%85%E5%AE%B9/" title="Docker的一些内容"><img class="cover" src="/img/3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Docker的一些内容</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/77524161?v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ChengHuiWan-cy</div><div class="author-info__description">努力刷力扣当中......</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ChengHuiWan-cy"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">一切还在建设当中</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95"><span class="toc-text">1.做题记录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E4%B8%80%E4%BA%9Bjava%E7%94%A8%E6%B3%95"><span class="toc-text">2.一些java用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0"><span class="toc-text">数学函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88Stack"><span class="toc-text">栈Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97Queue"><span class="toc-text">队列Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8LinkedList%E5%AE%9E%E7%8E%B0Queue"><span class="toc-text">使用LinkedList实现Queue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86PriorityQueue"><span class="toc-text">堆PriorityQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8List"><span class="toc-text">链表List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList"><span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList"><span class="toc-text">LinkedList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-text">String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder"><span class="toc-text">StringBuilder</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88Set-Collections"><span class="toc-text">集合Set(Collections)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%A0%E5%B0%84Map-Collections"><span class="toc-text">映射Map(Collections)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0"><span class="toc-text">3.做题笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-1"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">704.二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text">27.移除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="toc-text">977. 有序数组的平方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text">209.长度最小的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II"><span class="toc-text">59.螺旋矩阵II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1365-%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">1365.有多少小于当前数字的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#941-%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84"><span class="toc-text">941.有效的山脉数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1207-%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0"><span class="toc-text">1207.独一无二的出现次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-text">283. 移动零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-text">189. 旋转数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87"><span class="toc-text">724.寻找数组的中心下标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#922-%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II"><span class="toc-text">922. 按奇偶排序数组II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="toc-text">203.移除链表元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">206.反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">24. 两两交换链表中的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-text">19.删除链表的倒数第N个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="toc-text">160. 相交链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II"><span class="toc-text">142.环形链表II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-text">242.有效的字母异位词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-text">349. 两个数组的交集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#202-%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="toc-text">202.快乐数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">1.两数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#383-%E8%B5%8E%E9%87%91%E4%BF%A1"><span class="toc-text">383. 赎金信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">15.三数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">18.四数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II"><span class="toc-text">454.四数相加II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-1"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">344.反转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II"><span class="toc-text">541. 反转字符串II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-text">相关知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95%E8%AE%BA%EF%BC%9A"><span class="toc-text">动态规划方法论：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%EF%BC%9A%E6%8A%8A%E4%BA%8C%E7%BB%B4%E5%8E%8B%E7%BC%A9%E6%88%90%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%9A"><span class="toc-text">进阶：把二维压缩成一维数组：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-text">完全背包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%9A%84%E8%BF%9B%E9%98%B6%EF%BC%9A%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-text">完全背包的进阶：排列组合问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="toc-text">509. 斐波那契数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-text">70. 爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-text">746. 使用最小花费爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-text">62.不同路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II"><span class="toc-text">63. 不同路径 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-text">343. 整数拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">96.不同的二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-text">416. 分割等和子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII"><span class="toc-text">1049.最后一块石头的重量II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-text">279.完全平方数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-text">121. 买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII"><span class="toc-text">122.买卖股票的最佳时机II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII"><span class="toc-text">123.买卖股票的最佳时机III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV"><span class="toc-text">188.买卖股票的最佳时机IV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9"><span class="toc-text">714.买卖股票的最佳时机含手续费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-text">647. 回文子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-text">198.打家劫舍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII"><span class="toc-text">213.打家劫舍II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-III"><span class="toc-text">337.打家劫舍 III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97"><span class="toc-text">376. 摆动序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="toc-text">53. 最大子序和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">300.最长递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97"><span class="toc-text">674. 最长连续递增序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">1143.最长公共子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1035-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF"><span class="toc-text">1035.不相交的线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text">718. 最长重复子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#494-%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-text">494.目标和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#474-%E4%B8%80%E5%92%8C%E9%9B%B6"><span class="toc-text">474.一和零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II"><span class="toc-text">518.零钱兑换II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3"><span class="toc-text">377. 组合总和 Ⅳ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-text">322. 零钱兑换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="toc-text">309.最佳买卖股票时机含冷冻期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">392.判断子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">115.不同的子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#583-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">583. 两个字符串的删除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-text">72. 编辑距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">516.最长回文子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-text">42. 接雨水</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-text">栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-text">20. 有效的括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-text">1047. 删除字符串中的所有相邻重复项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-text">150. 逆波兰表达式求值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-text">347.前 K 个高频元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-text">贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="toc-text">455.分发饼干</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6"><span class="toc-text">860.柠檬水找零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="toc-text">135. 分发糖果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-text">55. 跳跃游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1005-K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-text">1005.K次取反后最大化的数组和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83"><span class="toc-text">452. 用最少数量的箭引爆气球</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="toc-text">435. 无重叠区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="toc-text">763.划分字母区间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-text">回溯算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86-1"><span class="toc-text">相关知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77-%E7%BB%84%E5%90%88"><span class="toc-text">77.组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII"><span class="toc-text">216.组合总和III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-text">17.电话号码的字母组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-text">131.分割回文串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#01%E8%BF%90%E7%AE%97"><span class="toc-text">01运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1356-%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B-1-%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F"><span class="toc-text">1356. 根据数字二进制下 1 的数目排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-text">单调栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="toc-text">739. 每日温度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I"><span class="toc-text">496.下一个更大元素 I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II"><span class="toc-text">503.下一个更大元素II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2"><span class="toc-text">84.柱状图中最大的矩形</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/15/%E5%86%8D%E5%86%B2%E4%B8%80%E6%8A%8A/" title="再冲一把"><img src="/img/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="再冲一把"/></a><div class="content"><a class="title" href="/2024/07/15/%E5%86%8D%E5%86%B2%E4%B8%80%E6%8A%8A/" title="再冲一把">再冲一把</a><time datetime="2024-07-15T08:05:48.000Z" title="发表于 2024-07-15 16:05:48">2024-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/05/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/" title="力扣笔记"><img src="/img/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="力扣笔记"/></a><div class="content"><a class="title" href="/2024/07/05/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/" title="力扣笔记">力扣笔记</a><time datetime="2024-07-05T05:55:27.000Z" title="发表于 2024-07-05 13:55:27">2024-07-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/27/Docker%E7%9A%84%E4%B8%80%E4%BA%9B%E5%86%85%E5%AE%B9/" title="Docker的一些内容"><img src="/img/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker的一些内容"/></a><div class="content"><a class="title" href="/2024/05/27/Docker%E7%9A%84%E4%B8%80%E4%BA%9B%E5%86%85%E5%AE%B9/" title="Docker的一些内容">Docker的一些内容</a><time datetime="2024-05-27T06:37:42.000Z" title="发表于 2024-05-27 14:37:42">2024-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/24/%E5%87%B8%E4%BC%98%E5%8C%96%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="组合优化与凸优化"><img src="/img/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="组合优化与凸优化"/></a><div class="content"><a class="title" href="/2024/05/24/%E5%87%B8%E4%BC%98%E5%8C%96%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="组合优化与凸优化">组合优化与凸优化</a><time datetime="2024-05-24T07:36:18.000Z" title="发表于 2024-05-24 15:36:18">2024-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/24/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" title="强化学习"><img src="/img/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="强化学习"/></a><div class="content"><a class="title" href="/2024/05/24/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" title="强化学习">强化学习</a><time datetime="2024-05-24T06:15:08.000Z" title="发表于 2024-05-24 14:15:08">2024-05-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By ChengHuiWan-cy</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>